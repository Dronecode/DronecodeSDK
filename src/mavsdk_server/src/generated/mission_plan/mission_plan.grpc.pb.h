// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: mission_plan/mission_plan.proto
#ifndef GRPC_mission_5fplan_2fmission_5fplan_2eproto__INCLUDED
#define GRPC_mission_5fplan_2fmission_5fplan_2eproto__INCLUDED

#include "mission_plan/mission_plan.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace mavsdk {
namespace rpc {
namespace mission_plan {

// Enable mission from QGC .plan files.
class MissionPlanService final {
 public:
  static constexpr char const* service_full_name() {
    return "mavsdk.rpc.mission_plan.MissionPlanService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    //
    // Upload a JSON .plan mission.
    //
    // The mission items are uploaded to a drone. Once uploaded the mission can be started and
    // executed even if the connection is lost.
    virtual ::grpc::Status UploadMissionPlan(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest& request, ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse>> AsyncUploadMissionPlan(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse>>(AsyncUploadMissionPlanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse>> PrepareAsyncUploadMissionPlan(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse>>(PrepareAsyncUploadMissionPlanRaw(context, request, cq));
    }
    //
    // Cancel an ongoing mission plan upload.
    virtual ::grpc::Status CancelMissionPlanUpload(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest& request, ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse>> AsyncCancelMissionPlanUpload(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse>>(AsyncCancelMissionPlanUploadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse>> PrepareAsyncCancelMissionPlanUpload(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse>>(PrepareAsyncCancelMissionPlanUploadRaw(context, request, cq));
    }
    //
    // Clear the mission plan (including geofence and rally points) saved on the vehicle.
    virtual ::grpc::Status ClearMissionPlan(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest& request, ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse>> AsyncClearMissionPlan(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse>>(AsyncClearMissionPlanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse>> PrepareAsyncClearMissionPlan(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse>>(PrepareAsyncClearMissionPlanRaw(context, request, cq));
    }
    //
    // Start the mission.
    //
    // A mission must be uploaded to the vehicle before this can be called.
    virtual ::grpc::Status StartMission(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::StartMissionRequest& request, ::mavsdk::rpc::mission_plan::StartMissionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::StartMissionResponse>> AsyncStartMission(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::StartMissionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::StartMissionResponse>>(AsyncStartMissionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::StartMissionResponse>> PrepareAsyncStartMission(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::StartMissionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::StartMissionResponse>>(PrepareAsyncStartMissionRaw(context, request, cq));
    }
    //
    // Pause the mission.
    //
    // Pausing the mission puts the vehicle into
    // [HOLD mode](https://docs.px4.io/en/flight_modes/hold.html).
    // A multicopter should just hover at the spot while a fixedwing vehicle should loiter
    // around the location where it paused.
    virtual ::grpc::Status PauseMission(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::PauseMissionRequest& request, ::mavsdk::rpc::mission_plan::PauseMissionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::PauseMissionResponse>> AsyncPauseMission(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::PauseMissionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::PauseMissionResponse>>(AsyncPauseMissionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::PauseMissionResponse>> PrepareAsyncPauseMission(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::PauseMissionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::PauseMissionResponse>>(PrepareAsyncPauseMissionRaw(context, request, cq));
    }
    //
    // Sets the mission plan item index to go to.
    //
    // By setting the current index to 0, the mission is restarted from the beginning.
    //
    // Note that this is not necessarily true for general missions using MAVLink if loop counters
    // are used.
    virtual ::grpc::Status SetCurrentMissionItem(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest& request, ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse>> AsyncSetCurrentMissionItem(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse>>(AsyncSetCurrentMissionItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse>> PrepareAsyncSetCurrentMissionItem(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse>>(PrepareAsyncSetCurrentMissionItemRaw(context, request, cq));
    }
    //
    // Check if the mission has been finished.
    virtual ::grpc::Status IsMissionFinished(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest& request, ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse>> AsyncIsMissionFinished(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse>>(AsyncIsMissionFinishedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse>> PrepareAsyncIsMissionFinished(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse>>(PrepareAsyncIsMissionFinishedRaw(context, request, cq));
    }
    //
    // Subscribe to mission progress updates.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::mavsdk::rpc::mission_plan::MissionProgressResponse>> SubscribeMissionProgress(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::mavsdk::rpc::mission_plan::MissionProgressResponse>>(SubscribeMissionProgressRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::mission_plan::MissionProgressResponse>> AsyncSubscribeMissionProgress(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::mission_plan::MissionProgressResponse>>(AsyncSubscribeMissionProgressRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::mission_plan::MissionProgressResponse>> PrepareAsyncSubscribeMissionProgress(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::mission_plan::MissionProgressResponse>>(PrepareAsyncSubscribeMissionProgressRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      //
      // Upload a JSON .plan mission.
      //
      // The mission items are uploaded to a drone. Once uploaded the mission can be started and
      // executed even if the connection is lost.
      virtual void UploadMissionPlan(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest* request, ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UploadMissionPlan(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest* request, ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UploadMissionPlan(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest* request, ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Cancel an ongoing mission plan upload.
      virtual void CancelMissionPlanUpload(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest* request, ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CancelMissionPlanUpload(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest* request, ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CancelMissionPlanUpload(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest* request, ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Clear the mission plan (including geofence and rally points) saved on the vehicle.
      virtual void ClearMissionPlan(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest* request, ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ClearMissionPlan(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest* request, ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ClearMissionPlan(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest* request, ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Start the mission.
      //
      // A mission must be uploaded to the vehicle before this can be called.
      virtual void StartMission(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::StartMissionRequest* request, ::mavsdk::rpc::mission_plan::StartMissionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void StartMission(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::StartMissionRequest* request, ::mavsdk::rpc::mission_plan::StartMissionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void StartMission(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::StartMissionRequest* request, ::mavsdk::rpc::mission_plan::StartMissionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Pause the mission.
      //
      // Pausing the mission puts the vehicle into
      // [HOLD mode](https://docs.px4.io/en/flight_modes/hold.html).
      // A multicopter should just hover at the spot while a fixedwing vehicle should loiter
      // around the location where it paused.
      virtual void PauseMission(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::PauseMissionRequest* request, ::mavsdk::rpc::mission_plan::PauseMissionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PauseMission(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::PauseMissionRequest* request, ::mavsdk::rpc::mission_plan::PauseMissionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PauseMission(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::PauseMissionRequest* request, ::mavsdk::rpc::mission_plan::PauseMissionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Sets the mission plan item index to go to.
      //
      // By setting the current index to 0, the mission is restarted from the beginning.
      //
      // Note that this is not necessarily true for general missions using MAVLink if loop counters
      // are used.
      virtual void SetCurrentMissionItem(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest* request, ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SetCurrentMissionItem(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest* request, ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SetCurrentMissionItem(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest* request, ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Check if the mission has been finished.
      virtual void IsMissionFinished(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest* request, ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void IsMissionFinished(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest* request, ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void IsMissionFinished(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest* request, ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Subscribe to mission progress updates.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SubscribeMissionProgress(::grpc::ClientContext* context, ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest* request, ::grpc::ClientReadReactor< ::mavsdk::rpc::mission_plan::MissionProgressResponse>* reactor) = 0;
      #else
      virtual void SubscribeMissionProgress(::grpc::ClientContext* context, ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest* request, ::grpc::experimental::ClientReadReactor< ::mavsdk::rpc::mission_plan::MissionProgressResponse>* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse>* AsyncUploadMissionPlanRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse>* PrepareAsyncUploadMissionPlanRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse>* AsyncCancelMissionPlanUploadRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse>* PrepareAsyncCancelMissionPlanUploadRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse>* AsyncClearMissionPlanRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse>* PrepareAsyncClearMissionPlanRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::StartMissionResponse>* AsyncStartMissionRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::StartMissionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::StartMissionResponse>* PrepareAsyncStartMissionRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::StartMissionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::PauseMissionResponse>* AsyncPauseMissionRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::PauseMissionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::PauseMissionResponse>* PrepareAsyncPauseMissionRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::PauseMissionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse>* AsyncSetCurrentMissionItemRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse>* PrepareAsyncSetCurrentMissionItemRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse>* AsyncIsMissionFinishedRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse>* PrepareAsyncIsMissionFinishedRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::mavsdk::rpc::mission_plan::MissionProgressResponse>* SubscribeMissionProgressRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::mission_plan::MissionProgressResponse>* AsyncSubscribeMissionProgressRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::mavsdk::rpc::mission_plan::MissionProgressResponse>* PrepareAsyncSubscribeMissionProgressRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status UploadMissionPlan(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest& request, ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse>> AsyncUploadMissionPlan(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse>>(AsyncUploadMissionPlanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse>> PrepareAsyncUploadMissionPlan(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse>>(PrepareAsyncUploadMissionPlanRaw(context, request, cq));
    }
    ::grpc::Status CancelMissionPlanUpload(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest& request, ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse>> AsyncCancelMissionPlanUpload(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse>>(AsyncCancelMissionPlanUploadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse>> PrepareAsyncCancelMissionPlanUpload(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse>>(PrepareAsyncCancelMissionPlanUploadRaw(context, request, cq));
    }
    ::grpc::Status ClearMissionPlan(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest& request, ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse>> AsyncClearMissionPlan(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse>>(AsyncClearMissionPlanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse>> PrepareAsyncClearMissionPlan(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse>>(PrepareAsyncClearMissionPlanRaw(context, request, cq));
    }
    ::grpc::Status StartMission(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::StartMissionRequest& request, ::mavsdk::rpc::mission_plan::StartMissionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::StartMissionResponse>> AsyncStartMission(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::StartMissionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::StartMissionResponse>>(AsyncStartMissionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::StartMissionResponse>> PrepareAsyncStartMission(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::StartMissionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::StartMissionResponse>>(PrepareAsyncStartMissionRaw(context, request, cq));
    }
    ::grpc::Status PauseMission(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::PauseMissionRequest& request, ::mavsdk::rpc::mission_plan::PauseMissionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::PauseMissionResponse>> AsyncPauseMission(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::PauseMissionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::PauseMissionResponse>>(AsyncPauseMissionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::PauseMissionResponse>> PrepareAsyncPauseMission(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::PauseMissionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::PauseMissionResponse>>(PrepareAsyncPauseMissionRaw(context, request, cq));
    }
    ::grpc::Status SetCurrentMissionItem(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest& request, ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse>> AsyncSetCurrentMissionItem(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse>>(AsyncSetCurrentMissionItemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse>> PrepareAsyncSetCurrentMissionItem(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse>>(PrepareAsyncSetCurrentMissionItemRaw(context, request, cq));
    }
    ::grpc::Status IsMissionFinished(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest& request, ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse>> AsyncIsMissionFinished(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse>>(AsyncIsMissionFinishedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse>> PrepareAsyncIsMissionFinished(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse>>(PrepareAsyncIsMissionFinishedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::mavsdk::rpc::mission_plan::MissionProgressResponse>> SubscribeMissionProgress(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::mavsdk::rpc::mission_plan::MissionProgressResponse>>(SubscribeMissionProgressRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::mission_plan::MissionProgressResponse>> AsyncSubscribeMissionProgress(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::mission_plan::MissionProgressResponse>>(AsyncSubscribeMissionProgressRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::mission_plan::MissionProgressResponse>> PrepareAsyncSubscribeMissionProgress(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::mavsdk::rpc::mission_plan::MissionProgressResponse>>(PrepareAsyncSubscribeMissionProgressRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void UploadMissionPlan(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest* request, ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UploadMissionPlan(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest* request, ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UploadMissionPlan(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest* request, ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CancelMissionPlanUpload(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest* request, ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CancelMissionPlanUpload(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest* request, ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CancelMissionPlanUpload(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest* request, ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ClearMissionPlan(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest* request, ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ClearMissionPlan(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest* request, ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ClearMissionPlan(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest* request, ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void StartMission(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::StartMissionRequest* request, ::mavsdk::rpc::mission_plan::StartMissionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void StartMission(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::StartMissionRequest* request, ::mavsdk::rpc::mission_plan::StartMissionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void StartMission(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::StartMissionRequest* request, ::mavsdk::rpc::mission_plan::StartMissionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PauseMission(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::PauseMissionRequest* request, ::mavsdk::rpc::mission_plan::PauseMissionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PauseMission(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::PauseMissionRequest* request, ::mavsdk::rpc::mission_plan::PauseMissionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PauseMission(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::PauseMissionRequest* request, ::mavsdk::rpc::mission_plan::PauseMissionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SetCurrentMissionItem(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest* request, ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SetCurrentMissionItem(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest* request, ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SetCurrentMissionItem(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest* request, ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void IsMissionFinished(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest* request, ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void IsMissionFinished(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest* request, ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void IsMissionFinished(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest* request, ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SubscribeMissionProgress(::grpc::ClientContext* context, ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest* request, ::grpc::ClientReadReactor< ::mavsdk::rpc::mission_plan::MissionProgressResponse>* reactor) override;
      #else
      void SubscribeMissionProgress(::grpc::ClientContext* context, ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest* request, ::grpc::experimental::ClientReadReactor< ::mavsdk::rpc::mission_plan::MissionProgressResponse>* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse>* AsyncUploadMissionPlanRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse>* PrepareAsyncUploadMissionPlanRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse>* AsyncCancelMissionPlanUploadRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse>* PrepareAsyncCancelMissionPlanUploadRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse>* AsyncClearMissionPlanRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse>* PrepareAsyncClearMissionPlanRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::StartMissionResponse>* AsyncStartMissionRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::StartMissionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::StartMissionResponse>* PrepareAsyncStartMissionRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::StartMissionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::PauseMissionResponse>* AsyncPauseMissionRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::PauseMissionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::PauseMissionResponse>* PrepareAsyncPauseMissionRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::PauseMissionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse>* AsyncSetCurrentMissionItemRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse>* PrepareAsyncSetCurrentMissionItemRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse>* AsyncIsMissionFinishedRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse>* PrepareAsyncIsMissionFinishedRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::mavsdk::rpc::mission_plan::MissionProgressResponse>* SubscribeMissionProgressRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest& request) override;
    ::grpc::ClientAsyncReader< ::mavsdk::rpc::mission_plan::MissionProgressResponse>* AsyncSubscribeMissionProgressRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::mavsdk::rpc::mission_plan::MissionProgressResponse>* PrepareAsyncSubscribeMissionProgressRaw(::grpc::ClientContext* context, const ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_UploadMissionPlan_;
    const ::grpc::internal::RpcMethod rpcmethod_CancelMissionPlanUpload_;
    const ::grpc::internal::RpcMethod rpcmethod_ClearMissionPlan_;
    const ::grpc::internal::RpcMethod rpcmethod_StartMission_;
    const ::grpc::internal::RpcMethod rpcmethod_PauseMission_;
    const ::grpc::internal::RpcMethod rpcmethod_SetCurrentMissionItem_;
    const ::grpc::internal::RpcMethod rpcmethod_IsMissionFinished_;
    const ::grpc::internal::RpcMethod rpcmethod_SubscribeMissionProgress_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    //
    // Upload a JSON .plan mission.
    //
    // The mission items are uploaded to a drone. Once uploaded the mission can be started and
    // executed even if the connection is lost.
    virtual ::grpc::Status UploadMissionPlan(::grpc::ServerContext* context, const ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest* request, ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse* response);
    //
    // Cancel an ongoing mission plan upload.
    virtual ::grpc::Status CancelMissionPlanUpload(::grpc::ServerContext* context, const ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest* request, ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse* response);
    //
    // Clear the mission plan (including geofence and rally points) saved on the vehicle.
    virtual ::grpc::Status ClearMissionPlan(::grpc::ServerContext* context, const ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest* request, ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse* response);
    //
    // Start the mission.
    //
    // A mission must be uploaded to the vehicle before this can be called.
    virtual ::grpc::Status StartMission(::grpc::ServerContext* context, const ::mavsdk::rpc::mission_plan::StartMissionRequest* request, ::mavsdk::rpc::mission_plan::StartMissionResponse* response);
    //
    // Pause the mission.
    //
    // Pausing the mission puts the vehicle into
    // [HOLD mode](https://docs.px4.io/en/flight_modes/hold.html).
    // A multicopter should just hover at the spot while a fixedwing vehicle should loiter
    // around the location where it paused.
    virtual ::grpc::Status PauseMission(::grpc::ServerContext* context, const ::mavsdk::rpc::mission_plan::PauseMissionRequest* request, ::mavsdk::rpc::mission_plan::PauseMissionResponse* response);
    //
    // Sets the mission plan item index to go to.
    //
    // By setting the current index to 0, the mission is restarted from the beginning.
    //
    // Note that this is not necessarily true for general missions using MAVLink if loop counters
    // are used.
    virtual ::grpc::Status SetCurrentMissionItem(::grpc::ServerContext* context, const ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest* request, ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse* response);
    //
    // Check if the mission has been finished.
    virtual ::grpc::Status IsMissionFinished(::grpc::ServerContext* context, const ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest* request, ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse* response);
    //
    // Subscribe to mission progress updates.
    virtual ::grpc::Status SubscribeMissionProgress(::grpc::ServerContext* context, const ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest* request, ::grpc::ServerWriter< ::mavsdk::rpc::mission_plan::MissionProgressResponse>* writer);
  };
  template <class BaseClass>
  class WithAsyncMethod_UploadMissionPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UploadMissionPlan() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_UploadMissionPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadMissionPlan(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest* /*request*/, ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadMissionPlan(::grpc::ServerContext* context, ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CancelMissionPlanUpload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CancelMissionPlanUpload() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_CancelMissionPlanUpload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelMissionPlanUpload(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest* /*request*/, ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCancelMissionPlanUpload(::grpc::ServerContext* context, ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ClearMissionPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ClearMissionPlan() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_ClearMissionPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearMissionPlan(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest* /*request*/, ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClearMissionPlan(::grpc::ServerContext* context, ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StartMission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StartMission() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_StartMission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartMission(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::StartMissionRequest* /*request*/, ::mavsdk::rpc::mission_plan::StartMissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartMission(::grpc::ServerContext* context, ::mavsdk::rpc::mission_plan::StartMissionRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::mission_plan::StartMissionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PauseMission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PauseMission() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_PauseMission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseMission(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::PauseMissionRequest* /*request*/, ::mavsdk::rpc::mission_plan::PauseMissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPauseMission(::grpc::ServerContext* context, ::mavsdk::rpc::mission_plan::PauseMissionRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::mission_plan::PauseMissionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetCurrentMissionItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetCurrentMissionItem() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_SetCurrentMissionItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCurrentMissionItem(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest* /*request*/, ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCurrentMissionItem(::grpc::ServerContext* context, ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_IsMissionFinished : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_IsMissionFinished() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_IsMissionFinished() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsMissionFinished(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest* /*request*/, ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsMissionFinished(::grpc::ServerContext* context, ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest* request, ::grpc::ServerAsyncResponseWriter< ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SubscribeMissionProgress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SubscribeMissionProgress() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_SubscribeMissionProgress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeMissionProgress(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::mission_plan::MissionProgressResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeMissionProgress(::grpc::ServerContext* context, ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest* request, ::grpc::ServerAsyncWriter< ::mavsdk::rpc::mission_plan::MissionProgressResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(7, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_UploadMissionPlan<WithAsyncMethod_CancelMissionPlanUpload<WithAsyncMethod_ClearMissionPlan<WithAsyncMethod_StartMission<WithAsyncMethod_PauseMission<WithAsyncMethod_SetCurrentMissionItem<WithAsyncMethod_IsMissionFinished<WithAsyncMethod_SubscribeMissionProgress<Service > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UploadMissionPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UploadMissionPlan() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest, ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest* request, ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse* response) { return this->UploadMissionPlan(context, request, response); }));}
    void SetMessageAllocatorFor_UploadMissionPlan(
        ::grpc::experimental::MessageAllocator< ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest, ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest, ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UploadMissionPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadMissionPlan(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest* /*request*/, ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UploadMissionPlan(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest* /*request*/, ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UploadMissionPlan(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest* /*request*/, ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CancelMissionPlanUpload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CancelMissionPlanUpload() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest, ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest* request, ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse* response) { return this->CancelMissionPlanUpload(context, request, response); }));}
    void SetMessageAllocatorFor_CancelMissionPlanUpload(
        ::grpc::experimental::MessageAllocator< ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest, ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest, ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CancelMissionPlanUpload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelMissionPlanUpload(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest* /*request*/, ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CancelMissionPlanUpload(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest* /*request*/, ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CancelMissionPlanUpload(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest* /*request*/, ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ClearMissionPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ClearMissionPlan() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest, ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest* request, ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse* response) { return this->ClearMissionPlan(context, request, response); }));}
    void SetMessageAllocatorFor_ClearMissionPlan(
        ::grpc::experimental::MessageAllocator< ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest, ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest, ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ClearMissionPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearMissionPlan(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest* /*request*/, ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ClearMissionPlan(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest* /*request*/, ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ClearMissionPlan(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest* /*request*/, ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StartMission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_StartMission() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::mission_plan::StartMissionRequest, ::mavsdk::rpc::mission_plan::StartMissionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mavsdk::rpc::mission_plan::StartMissionRequest* request, ::mavsdk::rpc::mission_plan::StartMissionResponse* response) { return this->StartMission(context, request, response); }));}
    void SetMessageAllocatorFor_StartMission(
        ::grpc::experimental::MessageAllocator< ::mavsdk::rpc::mission_plan::StartMissionRequest, ::mavsdk::rpc::mission_plan::StartMissionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::mission_plan::StartMissionRequest, ::mavsdk::rpc::mission_plan::StartMissionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StartMission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartMission(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::StartMissionRequest* /*request*/, ::mavsdk::rpc::mission_plan::StartMissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* StartMission(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::StartMissionRequest* /*request*/, ::mavsdk::rpc::mission_plan::StartMissionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* StartMission(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::StartMissionRequest* /*request*/, ::mavsdk::rpc::mission_plan::StartMissionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PauseMission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PauseMission() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::mission_plan::PauseMissionRequest, ::mavsdk::rpc::mission_plan::PauseMissionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mavsdk::rpc::mission_plan::PauseMissionRequest* request, ::mavsdk::rpc::mission_plan::PauseMissionResponse* response) { return this->PauseMission(context, request, response); }));}
    void SetMessageAllocatorFor_PauseMission(
        ::grpc::experimental::MessageAllocator< ::mavsdk::rpc::mission_plan::PauseMissionRequest, ::mavsdk::rpc::mission_plan::PauseMissionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::mission_plan::PauseMissionRequest, ::mavsdk::rpc::mission_plan::PauseMissionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PauseMission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseMission(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::PauseMissionRequest* /*request*/, ::mavsdk::rpc::mission_plan::PauseMissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PauseMission(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::PauseMissionRequest* /*request*/, ::mavsdk::rpc::mission_plan::PauseMissionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PauseMission(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::PauseMissionRequest* /*request*/, ::mavsdk::rpc::mission_plan::PauseMissionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SetCurrentMissionItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SetCurrentMissionItem() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest, ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest* request, ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse* response) { return this->SetCurrentMissionItem(context, request, response); }));}
    void SetMessageAllocatorFor_SetCurrentMissionItem(
        ::grpc::experimental::MessageAllocator< ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest, ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest, ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SetCurrentMissionItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCurrentMissionItem(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest* /*request*/, ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetCurrentMissionItem(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest* /*request*/, ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetCurrentMissionItem(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest* /*request*/, ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_IsMissionFinished : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_IsMissionFinished() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest, ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest* request, ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse* response) { return this->IsMissionFinished(context, request, response); }));}
    void SetMessageAllocatorFor_IsMissionFinished(
        ::grpc::experimental::MessageAllocator< ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest, ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest, ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_IsMissionFinished() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsMissionFinished(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest* /*request*/, ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* IsMissionFinished(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest* /*request*/, ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* IsMissionFinished(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest* /*request*/, ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SubscribeMissionProgress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SubscribeMissionProgress() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc::internal::CallbackServerStreamingHandler< ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest, ::mavsdk::rpc::mission_plan::MissionProgressResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest* request) { return this->SubscribeMissionProgress(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_SubscribeMissionProgress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeMissionProgress(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::mission_plan::MissionProgressResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::mavsdk::rpc::mission_plan::MissionProgressResponse>* SubscribeMissionProgress(
      ::grpc::CallbackServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::mavsdk::rpc::mission_plan::MissionProgressResponse>* SubscribeMissionProgress(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_UploadMissionPlan<ExperimentalWithCallbackMethod_CancelMissionPlanUpload<ExperimentalWithCallbackMethod_ClearMissionPlan<ExperimentalWithCallbackMethod_StartMission<ExperimentalWithCallbackMethod_PauseMission<ExperimentalWithCallbackMethod_SetCurrentMissionItem<ExperimentalWithCallbackMethod_IsMissionFinished<ExperimentalWithCallbackMethod_SubscribeMissionProgress<Service > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_UploadMissionPlan<ExperimentalWithCallbackMethod_CancelMissionPlanUpload<ExperimentalWithCallbackMethod_ClearMissionPlan<ExperimentalWithCallbackMethod_StartMission<ExperimentalWithCallbackMethod_PauseMission<ExperimentalWithCallbackMethod_SetCurrentMissionItem<ExperimentalWithCallbackMethod_IsMissionFinished<ExperimentalWithCallbackMethod_SubscribeMissionProgress<Service > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_UploadMissionPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UploadMissionPlan() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_UploadMissionPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadMissionPlan(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest* /*request*/, ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CancelMissionPlanUpload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CancelMissionPlanUpload() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_CancelMissionPlanUpload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelMissionPlanUpload(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest* /*request*/, ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ClearMissionPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ClearMissionPlan() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_ClearMissionPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearMissionPlan(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest* /*request*/, ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StartMission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StartMission() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_StartMission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartMission(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::StartMissionRequest* /*request*/, ::mavsdk::rpc::mission_plan::StartMissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PauseMission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PauseMission() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_PauseMission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseMission(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::PauseMissionRequest* /*request*/, ::mavsdk::rpc::mission_plan::PauseMissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetCurrentMissionItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetCurrentMissionItem() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_SetCurrentMissionItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCurrentMissionItem(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest* /*request*/, ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_IsMissionFinished : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_IsMissionFinished() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_IsMissionFinished() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsMissionFinished(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest* /*request*/, ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SubscribeMissionProgress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SubscribeMissionProgress() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_SubscribeMissionProgress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeMissionProgress(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::mission_plan::MissionProgressResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_UploadMissionPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UploadMissionPlan() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_UploadMissionPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadMissionPlan(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest* /*request*/, ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadMissionPlan(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CancelMissionPlanUpload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CancelMissionPlanUpload() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_CancelMissionPlanUpload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelMissionPlanUpload(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest* /*request*/, ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCancelMissionPlanUpload(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ClearMissionPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ClearMissionPlan() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_ClearMissionPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearMissionPlan(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest* /*request*/, ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClearMissionPlan(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartMission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StartMission() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_StartMission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartMission(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::StartMissionRequest* /*request*/, ::mavsdk::rpc::mission_plan::StartMissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartMission(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PauseMission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PauseMission() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_PauseMission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseMission(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::PauseMissionRequest* /*request*/, ::mavsdk::rpc::mission_plan::PauseMissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPauseMission(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetCurrentMissionItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetCurrentMissionItem() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_SetCurrentMissionItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCurrentMissionItem(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest* /*request*/, ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCurrentMissionItem(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_IsMissionFinished : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_IsMissionFinished() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_IsMissionFinished() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsMissionFinished(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest* /*request*/, ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsMissionFinished(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SubscribeMissionProgress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SubscribeMissionProgress() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_SubscribeMissionProgress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeMissionProgress(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::mission_plan::MissionProgressResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSubscribeMissionProgress(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(7, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UploadMissionPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UploadMissionPlan() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UploadMissionPlan(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UploadMissionPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadMissionPlan(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest* /*request*/, ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UploadMissionPlan(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UploadMissionPlan(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CancelMissionPlanUpload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CancelMissionPlanUpload() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CancelMissionPlanUpload(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CancelMissionPlanUpload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CancelMissionPlanUpload(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest* /*request*/, ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CancelMissionPlanUpload(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CancelMissionPlanUpload(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ClearMissionPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ClearMissionPlan() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ClearMissionPlan(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ClearMissionPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClearMissionPlan(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest* /*request*/, ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ClearMissionPlan(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ClearMissionPlan(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StartMission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_StartMission() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StartMission(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_StartMission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartMission(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::StartMissionRequest* /*request*/, ::mavsdk::rpc::mission_plan::StartMissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* StartMission(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* StartMission(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PauseMission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PauseMission() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PauseMission(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PauseMission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PauseMission(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::PauseMissionRequest* /*request*/, ::mavsdk::rpc::mission_plan::PauseMissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PauseMission(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PauseMission(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SetCurrentMissionItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SetCurrentMissionItem() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetCurrentMissionItem(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SetCurrentMissionItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCurrentMissionItem(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest* /*request*/, ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SetCurrentMissionItem(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SetCurrentMissionItem(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_IsMissionFinished : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_IsMissionFinished() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->IsMissionFinished(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_IsMissionFinished() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsMissionFinished(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest* /*request*/, ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* IsMissionFinished(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* IsMissionFinished(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SubscribeMissionProgress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SubscribeMissionProgress() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->SubscribeMissionProgress(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_SubscribeMissionProgress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SubscribeMissionProgress(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::mission_plan::MissionProgressResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeMissionProgress(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* SubscribeMissionProgress(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UploadMissionPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UploadMissionPlan() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest, ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest, ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse>* streamer) {
                       return this->StreamedUploadMissionPlan(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UploadMissionPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UploadMissionPlan(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest* /*request*/, ::mavsdk::rpc::mission_plan::UploadMissionPlanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUploadMissionPlan(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::mission_plan::UploadMissionPlanRequest,::mavsdk::rpc::mission_plan::UploadMissionPlanResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CancelMissionPlanUpload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CancelMissionPlanUpload() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest, ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest, ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse>* streamer) {
                       return this->StreamedCancelMissionPlanUpload(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CancelMissionPlanUpload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CancelMissionPlanUpload(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest* /*request*/, ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCancelMissionPlanUpload(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::mission_plan::CancelMissionPlanUploadRequest,::mavsdk::rpc::mission_plan::CancelMissionPlanUploadResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ClearMissionPlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ClearMissionPlan() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest, ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest, ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse>* streamer) {
                       return this->StreamedClearMissionPlan(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ClearMissionPlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ClearMissionPlan(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest* /*request*/, ::mavsdk::rpc::mission_plan::ClearMissionPlanResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedClearMissionPlan(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::mission_plan::ClearMissionPlanRequest,::mavsdk::rpc::mission_plan::ClearMissionPlanResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartMission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StartMission() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::mission_plan::StartMissionRequest, ::mavsdk::rpc::mission_plan::StartMissionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::mission_plan::StartMissionRequest, ::mavsdk::rpc::mission_plan::StartMissionResponse>* streamer) {
                       return this->StreamedStartMission(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StartMission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartMission(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::StartMissionRequest* /*request*/, ::mavsdk::rpc::mission_plan::StartMissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartMission(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::mission_plan::StartMissionRequest,::mavsdk::rpc::mission_plan::StartMissionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PauseMission : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PauseMission() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::mission_plan::PauseMissionRequest, ::mavsdk::rpc::mission_plan::PauseMissionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::mission_plan::PauseMissionRequest, ::mavsdk::rpc::mission_plan::PauseMissionResponse>* streamer) {
                       return this->StreamedPauseMission(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PauseMission() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PauseMission(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::PauseMissionRequest* /*request*/, ::mavsdk::rpc::mission_plan::PauseMissionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPauseMission(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::mission_plan::PauseMissionRequest,::mavsdk::rpc::mission_plan::PauseMissionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetCurrentMissionItem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetCurrentMissionItem() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest, ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest, ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse>* streamer) {
                       return this->StreamedSetCurrentMissionItem(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetCurrentMissionItem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetCurrentMissionItem(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest* /*request*/, ::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetCurrentMissionItem(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::mission_plan::SetCurrentMissionItemRequest,::mavsdk::rpc::mission_plan::SetCurrentMissionItemResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_IsMissionFinished : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_IsMissionFinished() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest, ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest, ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse>* streamer) {
                       return this->StreamedIsMissionFinished(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_IsMissionFinished() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status IsMissionFinished(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest* /*request*/, ::mavsdk::rpc::mission_plan::IsMissionFinishedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedIsMissionFinished(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::mavsdk::rpc::mission_plan::IsMissionFinishedRequest,::mavsdk::rpc::mission_plan::IsMissionFinishedResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_UploadMissionPlan<WithStreamedUnaryMethod_CancelMissionPlanUpload<WithStreamedUnaryMethod_ClearMissionPlan<WithStreamedUnaryMethod_StartMission<WithStreamedUnaryMethod_PauseMission<WithStreamedUnaryMethod_SetCurrentMissionItem<WithStreamedUnaryMethod_IsMissionFinished<Service > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_SubscribeMissionProgress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SubscribeMissionProgress() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest, ::mavsdk::rpc::mission_plan::MissionProgressResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest, ::mavsdk::rpc::mission_plan::MissionProgressResponse>* streamer) {
                       return this->StreamedSubscribeMissionProgress(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_SubscribeMissionProgress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SubscribeMissionProgress(::grpc::ServerContext* /*context*/, const ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest* /*request*/, ::grpc::ServerWriter< ::mavsdk::rpc::mission_plan::MissionProgressResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSubscribeMissionProgress(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::mavsdk::rpc::mission_plan::SubscribeMissionProgressRequest,::mavsdk::rpc::mission_plan::MissionProgressResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_SubscribeMissionProgress<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_UploadMissionPlan<WithStreamedUnaryMethod_CancelMissionPlanUpload<WithStreamedUnaryMethod_ClearMissionPlan<WithStreamedUnaryMethod_StartMission<WithStreamedUnaryMethod_PauseMission<WithStreamedUnaryMethod_SetCurrentMissionItem<WithStreamedUnaryMethod_IsMissionFinished<WithSplitStreamingMethod_SubscribeMissionProgress<Service > > > > > > > > StreamedService;
};

}  // namespace mission_plan
}  // namespace rpc
}  // namespace mavsdk


#endif  // GRPC_mission_5fplan_2fmission_5fplan_2eproto__INCLUDED
